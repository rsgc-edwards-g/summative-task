# Summative Task

## Overall goal

My summative task will be a 3-Dimensional representation of the concept of gravity and its effects in physics.

I will code a simulation of gravity's effects on space-time as well as light. Each of my simulations will show these effects from the perspective of an omnipotent observer looking at 2-D space-time as well as an observer in space-time.

To show these multiple perspectives, I will be using Processing's 3-Dimensional transformations. 

In my simulations, I intend to show gravity's effect on light itself through gravitational lensing, gravity's effects on orbits and gravity's contributions to the compression of the core of a dying star.

## Sub-goals

* research Processing's P3D rendering functions
* create an accurate depiction of 2-D space-time for simulations
* accurately represent gravity's effects on space-time and celestial objects
* represent forces with vectors in simulations
* make my simulations interactive by adding a way for a user to change masses of objects (objects will have radii but their mass will be treated as entirely at their centers)
* track the motions and states of objects as simulations progress, including telling the user when the simulation is completed


## Question Answers:
1. For my 2D simulation, users need to know that it simulates gravity's effects in space on planetary objects. They should also know that it requires them to click anywhere on the screen to create a new "planet" and to give that planet an initial trajectory and velocity. Finally, they should know that the commands listed in the top-left corner are commands they can give to the simulation. For my 3D simulation, all the user needs to know is that it is a simulation of the death of a star destined to become a white dwarf star and that they can choose how they look at it by moving their cursor.
2. For my 2D simulation, user command keystrokes are listed in the top-left corner. They also need to know that the line going to their cursor represents the trajectory of a new planet and the length of the line represents the planet's velocity and that a new planet is only created when they click. User's should also know that any planets that hit the sun add to its mass. For my 3D simulation, users only need to know that they can change their view of the simulation by moving their cursor.
3. In my 2D simulation, my Celestial class (https://github.com/rsgc-edwards-g/summative-task/blob/master/Project2D/Celestial.pde) best shows how I've used inheritance in my project because Celestial is never called directly from Project2D but, since stars and planets are so similar, they both extend Celestial and use similar functions. In my 3D project, I could have put the "core" code inside the "star" code to make things simpler. However, I feel that this actually makes the code simpler because the star and the core do different things when the star dies. This means that a distinction between a star and its core is very important as cores will always be shrinking but the star itself grows and then shrinks. Finally, my use of a CVector class (https://github.com/rsgc-edwards-g/summative-task/blob/master/Project/CVector.java) in both simulations shows inheritance as all CVectors have a vast selection of functions that make them easy to manipulate and use for the simulations.
4. I feel that I've extensively documented the purpose of each important line of code I have, telling users not only what I'm doing, but also why I'm doing it (and how I'm doing it if it's a set of steps). I also feel that my class, variable and function names also provide some description as to what I am doing, provided the user has at least a basic knowledge of astrophysics. Example: Core's Collapse function (https://github.com/rsgc-edwards-g/summative-task/blob/master/Project/Core.pde#L35-L51)
5. In my 2D simulation of gravity and orbits, the most important function is the checkForce function in planet (https://github.com/rsgc-edwards-g/summative-task/blob/master/Project2D/Planet.pde#L27-L38). While the starCollision function is important, the simulation is of gravity's effects on orbits, and the checkForce function is the function that determines a planet's orbit. In fact, the starCollision function wouldn't even be necessary without the checkForce function. For my 3D simulation, the display functions are important because they draw the star and core in 3D. However, the star.death (https://github.com/rsgc-edwards-g/summative-task/blob/master/Project/Star.pde#L34-L55) and core.collapse (https://github.com/rsgc-edwards-g/summative-task/blob/master/Project/Core.pde#L35-L51) functions are the most important because they cause the star to expand and contract, creating the simulation of a star's death.
6. For my 2D simulation, all a user has to do is click and the simulation will run. Then, they can alter aspects of the simulation by only clicking 3 keys, making it a very simple program to use. My 3D simulation is even easier to use since a user just has to click play and the simulation will automatically start.
7. Through my project, I feel I have committed frequently and been very descriptive with my commit messages. When I was first researching 3D Processing, I described the function of each new function's purpose in my commits so that I could track what functions P3D had and what they did. At this point, even though I was committing everything within the span of a few days, I still separated my commits so that no commit had too much change in it. Then, when I started work on my project, I continued to describe each of the changes I made to my code in my commit messages and tried to limit how many changes I made in a single commit. I think I could have committed more frequently as I was developing my project. However, I think when I finally figured out how I wanted to proceed with my project, I began to commit very frequently.